<!DOCTYPE html>
<html>
<head>
    <title>Local Linear Trend models for time series</title>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1' name='viewport'/>
    <meta name='description' content='Gregory Gundersen is a PhD candidate at Princeton.'>
    <meta name='keywords' content=''>
    <meta name='author' content='Gregory Gundersen'>
    
    <link href='/css/blog.css' rel='stylesheet'/>
    <link href='/css/trac.css' rel='stylesheet'/>
    <link href='/css/markdown.css' rel='stylesheet'/>
    
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>
    
    <script type='text/x-mathjax-config'>
MathJax.Hub.Config({
  jax: ['input/TeX', 'output/HTML-CSS'],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    extensions: ['color.js']
  },
  messageStyle: 'none',
  'HTML-CSS': { preferredFont: 'TeX', availableFonts: ['STIX','TeX'] }
});
</script>

<script src='//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML' type='text/javascript'></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
</head>
<body>
    <div class='content'>
        <div class='nav'>
    <ul class='wrap'>
        <li><a href='/'>Home</a></li>
        <li><a href='/blog'>Blog</a></li>
        <li><a href='/feed.xml'>RSS</a></li>
    </ul>
</div>
        <div class='front-matter'>
            <div class='wrap'>
                <h1>Local Linear Trend models for time series</h1>
                <h4></h4>
                <div class='bylines'>
                    <div class='byline'>
                        <h3>Published</h3>
                        <p>02 March 2021</p>
                    </div>
                </div>
                <div class='clear'></div>
            </div>
        </div>
        <div class='wrap article'>
            <div class='post'>    
    <div class="post-metadata">
        <span class="post-date">02 March 2021</span>
    </div>

    <div class="post-content">
        <p>The bedrock idea of modern statistics is exchangability. An exchangeable sequence of random variables is a sequence $X_1, X_2, X_3, \ldots$ whose joint probability distribution does not change when the positions in the sequence in which finitely many of them appear are altered. Informally, this means that you could permute the sequence and this would not change the inferences about it.</p>

<p>Not all problems have this nice feature. The most common non-exchangeable problem is the inference of parameters in a time series. Time series analysis is a fundamental technique in data science that helps us understand and predict patterns in sequential data that evolves over time. Here, if you permute the sequence you lose all the information about what point came in which order-the essential feature of a time series.</p>

<p>Among the various approaches to time series modeling, Local Linear Trend (LLT) models stand out for their simplicity and  effectiveness. These models are particularly useful when you need to:</p>

<ol>
  <li>Track gradual changes in the underlying trend of your data</li>
  <li>apture both the level and rate of change at each time point</li>
  <li>Make short to medium-term forecasts while accounting for uncertainty</li>
</ol>

<p>LLT models achieve this by decomposing a time series into two key components:</p>

<ol>
  <li>A level component that represents the current value of the series.</li>
  <li>A trend component that captures the rate of change.</li>
</ol>

<p>You can think of am LLT as a time varying regression slope, the level component moves up (and down!) the $y$-axis as time progresses, whilst the trend component rotates around the level. This approach is particularly valuable in scenarios where the trend isn’t fixed but evolves over time - think of retail sales during a period of economic growth, or user adoption of a new technology.</p>

<p>In this post, we’ll walk through implementing LLT models in Python using Stan. We’ll use the classic air passengers dataset as our example, which exhibits both trend and seasonal patterns, making it perfect for demonstrating the model’s capabilities.</p>

<p>The LLT model can be expressed by the following equations:</p>

<p>\(v_t \sim N(v_{t-1}, \sigma_v^2)\)
\(x_t \sim N(x_{t-1} + v_{t-1}, \sigma_x^2)\)
\(y_t \sim N(x_t, \sigma_y^2)\)
Where:</p>

<p>$v_t$ represents the trend velocity (rate of change) at time t
$x_t$ is the underlying state (level) of the system
$y_t$ is the observed value
$\sigma_v^2$ is the trend disturbance variance
$\sigma_x^2$ is the level disturbance variance
$\sigma_y^2$ is the observation error variance</p>

<p>Local Linear Trend models are one of the simplest time series models. Here we code them up in python.</p>

<p>We will model this in pystan, using the air passengers dataset.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pystan</span>
<span class="kn">import</span> <span class="nn">arviz</span> <span class="k">as</span> <span class="n">az</span>
<span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="k">as</span> <span class="n">mdates</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">pymc</span> <span class="k">as</span> <span class="n">pm</span>
<span class="n">RANDOM_SEED</span> <span class="o">=</span> <span class="mi">8927</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">RANDOM_SEED</span><span class="p">)</span>
<span class="n">az</span><span class="p">.</span><span class="n">style</span><span class="p">.</span><span class="n">use</span><span class="p">(</span><span class="s">"arviz-darkgrid"</span><span class="p">)</span>
<span class="o">%</span><span class="n">config</span> <span class="n">InlineBackend</span><span class="p">.</span><span class="n">figure_format</span> <span class="o">=</span> <span class="s">'retina'</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"../data/AirPassengers.csv"</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="s">"Month"</span><span class="p">])</span>
<span class="k">except</span> <span class="nb">FileNotFoundError</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">pm</span><span class="p">.</span><span class="n">get_data</span><span class="p">(</span><span class="s">"AirPassengers.csv"</span><span class="p">),</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="s">"Month"</span><span class="p">])</span>

<span class="n">df</span><span class="p">.</span><span class="n">plot</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">"Month"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">"#Passengers"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">"k"</span><span class="p">)</span>
</code></pre></div></div>

<p>This dataset tracks the monthly totals of a US airline passengers from 1949 to 1960. The time series displays a rising trend with multiplicative seasonality.</p>

<p>In stan we can write out model as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stan_code</span> <span class="o">=</span> <span class="s">"""data {
    int N;
    vector[N] X;
}

parameters {
    vector[N] u;
    vector[N] v;
    real&lt;lower=0&gt; s_u;
    real&lt;lower=0&gt; s_v;
    real&lt;lower=0&gt; s_x;
}

model {
    v[2:N] ~ normal(v[1:N-1], s_v);
    u[2:N] ~ normal(u[1:N-1] + v[1:N-1], s_u);
    X ~ normal(u, s_x);
}"""</span>
</code></pre></div></div>

<p>Stan programs are organized into blocks that serve different purposes in the statistical modeling process. The main blocks are:</p>

<ol>
  <li>
    <p><strong>Data.</strong> This block declares the data that your model expects. Variables declared here are treated as known/fixed, and with a fixed type (e.g. int, float, array etc).</p>
  </li>
  <li>
    <p><strong>Parameters.</strong> Declares the parameters that Stan will estimate, which are the unknowns in your model. Parameters cannot use integer types, they must be continuous. Constraints here are enforced during sampling, and good constraints can improve sampling efficiency.</p>
  </li>
  <li>
    <p><strong>Transformed Parameters.</strong> Declares and defines variables that depend on parameters. Useful for derived quantities that are used multiple times. Transformed parameters are computed once per iteration and can access both the data and parameter blocks (and are declared after them).</p>
  </li>
  <li>
    <p><strong>Model.</strong> Contains the actual statistical model. Uses sampling notation with the ~ symbol.</p>
  </li>
  <li>
    <p><strong>Generated Quantities.</strong> Computed after sampling. Used for: predictions, derived quantities, model checking statistics.</p>
  </li>
</ol>

<p>Let’s break this down section by section:</p>

<p>Data Block:</p>

<p>’'’stan
data {
    int N;          // Number of observations
    array[N] real X;    // Input data vector
}
‘’’
As input the the data the model expects is:</p>

<ul>
  <li>$N$ is an integer representing the number of time points in our series</li>
  <li>$X$ is a vector of length $N$ containing our actual observations (like passenger counts)</li>
</ul>

<p>’'’stan
parameters {
    array[N] real u;          // State/level vector
    array[N] real v;          // Velocity/trend vector
    real&lt;lower=0&gt; s_u;    // State noise standard deviation
    real&lt;lower=0&gt; s_v;    // Velocity noise standard deviation
    real&lt;lower=0&gt; s_x;    // Observation noise standard deviation
}
‘’’</p>

<p>This section defines the parameters we want Stan to estimate:</p>

<ul>
  <li>$u$ represents the underlying state (level) of the system at each time point</li>
  <li>$v$ represents the velocity (trend) at each time point</li>
  <li>The $s_$ parameters are standard deviations for different types of noise, constrained to be positive with &lt;lower=0&gt;</li>
</ul>

<p>’'’stan
model {
    for (t in 2:N) {
        v[t] ~ normal(v[t-1], s_v);
        u[t] ~ normal(u[t-1] + v[t-1], s_u);
    }
    X ~ normal(u, s_x);
}
‘’’</p>

<p>This is where the actual model is defined through three key relationships:</p>

<p>’'’stan
v[2:N] ~ normal(v[1:N-1], s_v)
‘’’</p>

<p>The velocity at each time point follows a random walk. Each velocity value is normally distributed around the previous velocity. $s_v$ controls how much the velocity can change between time points.</p>

<p>’'’stan
u[2:N] ~ normal(u[1:N-1] + v[1:N-1], s_u);
‘’’</p>

<p>The state at each time point depends on the previous state (u[1:N-1]) plus the previous velocity (v[1:N-1]). $s_u$ controls how much random variation is allowed in this relationship.</p>

<p>’'’stan
X ~ normal(u, s_x);
‘’’</p>

<p>Our observations $X$ are normally distributed around the true state $u$ with $s_x$ representing measurement noise or short-term fluctuations.</p>

<p>What makes this a “Local Linear Trend” model:</p>

<ol>
  <li>It’s “local” because the trend can change over time</li>
  <li>It’s “linear” because between any two adjacent time points, we model the change as linear (through the velocity term).</li>
  <li>It’s a “trend” model because it explicitly models the rate of change (velocity).</li>
</ol>

<p>We can run this model in Stan with the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data_feed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'X'</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s">'#Passengers'</span><span class="p">].</span><span class="n">values</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>  <span class="c1"># Ensure data is float
</span>    <span class="s">'N'</span><span class="p">:</span> <span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">sm</span> <span class="o">=</span> <span class="n">pystan</span><span class="p">.</span><span class="n">StanModel</span><span class="p">(</span><span class="n">model_code</span><span class="o">=</span><span class="n">stan_code</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">sm</span><span class="p">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data_feed</span><span class="p">,</span> <span class="nb">iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div></div>

<p>We can visually check the fit and the parameters with:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'u.'</span><span class="p">)]</span>
<span class="n">u_mean</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">u_columns</span><span class="p">].</span><span class="n">mean</span><span class="p">().</span><span class="n">values</span>
<span class="n">df</span><span class="p">[</span><span class="s">'pred'</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_mean</span>
<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s">'#Passengers'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Observed'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s">'pred'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Predicted'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Air Passengers: Observed vs Predicted'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Date'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Number of Passengers'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>We can measure our in sample fit with the following quantities:</p>

<p>’'’python</p>
<h1 id="get-fitted-values">Get fitted values</h1>
<p>fitted_values = u_mean</p>

<h1 id="calculate-metrics">Calculate metrics</h1>
<p>mse = np.mean((df[‘#Passengers’] - fitted_values)<strong>2)
rmse = np.sqrt(mse)
mae = np.mean(np.abs(df[‘#Passengers’] - fitted_values))
mape = np.mean(np.abs((df[‘#Passengers’] - fitted_values) / df[‘#Passengers’])) * 100
r2 = 1 - (np.sum((df[‘#Passengers’] - fitted_values)</strong>2) / 
          np.sum((df[‘#Passengers’] - df[‘#Passengers’].mean())**2))</p>

<p>print(f’MSE: {mse:.2f}’)
print(f’RMSE: {rmse:.2f}’)
print(f’MAE: {mae:.2f}’)
print(f’MAPE: {mape:.2f}%’)
print(f’R²: {r2:.4f}’)
‘’’</p>

<p>I get</p>

<p>MSE: 121.76
RMSE: 11.03
MAE: 8.12
MAPE: 2.79%
R²: 0.9915</p>

<p>Which indicates a pretty good fit:</p>

<ul>
  <li>Average error around 11 passengers (RMSE)</li>
  <li>Only 2.79% average percentage error (MAPE)</li>
</ul>

<p>The low MAPE and high R² suggest the model captures both the trend and seasonal patterns. The RMSE of 11 passengers is quite small given the scale of passenger numbers in the dataset.</p>

<p>To predict future points, we have to include the extra points in the original stan code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stan_code</span> <span class="o">=</span> <span class="s">"""data {
    int&lt;lower=0&gt; N;
    int pred_num;
    array[N] real X;
}

parameters {
    array[N] real u;
    array[N] real v;
    real&lt;lower=0&gt; s_u;
    real&lt;lower=0&gt; s_v;
    real&lt;lower=0&gt; s_x;
}

model {

    s_u ~ cauchy(0, 2.5);  // Half-cauchy prior
    s_v ~ cauchy(0, 2.5);  // Half-cauchy prior
    s_x ~ cauchy(0, 2.5);  // Half-cauchy prior
    
    for (t in 2:N) {
        v[t] ~ normal(v[t-1], s_v);
        u[t] ~ normal(u[t-1] + v[t-1], s_u);
    }
    X ~ normal(u, s_x);
}
    
generated quantities {
    array[N + pred_num] real u_pred;
    array[pred_num] real x_pred;
    
    // Copy the u values to u_pred
    for (n in 1:N) {
        u_pred[n] = u[n];
    }
    
    // Generate predictions
    for (i in 1:pred_num) {
        u_pred[N+i] = normal_rng(u_pred[N+i-1], s_u);
        x_pred[i] = normal_rng(u_pred[N+i], s_x);
    }
}
"""</span>
</code></pre></div></div>

<p>Here the Generated Quantities block predicts future states based on previous states (<code class="language-plaintext highlighter-rouge">normal_rng(u_pred[N+i-1], s_u)</code>), then generates observations from those states (<code class="language-plaintext highlighter-rouge">normal_rng(u_pred[N+i], s_x)</code>).</p>

<p>We can run the model with this code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data_feed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'X'</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s">'#Passengers'</span><span class="p">].</span><span class="n">values</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>  <span class="c1"># Ensure data is float
</span>    <span class="s">'N'</span><span class="p">:</span> <span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="s">'pred_num'</span><span class="p">:</span> <span class="mi">12</span>
<span class="p">}</span>
<span class="n">posterior</span> <span class="o">=</span> <span class="n">stan</span><span class="p">.</span><span class="n">build</span><span class="p">(</span><span class="n">stan_code</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data_feed</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">RANDOM_SEED</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">posterior</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_chains</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div></div>

<p>And then plot the fit and the predictions like so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parameters</span> <span class="o">=</span> <span class="n">fit</span><span class="p">.</span><span class="n">to_frame</span><span class="p">()</span>
<span class="n">u_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'u.'</span><span class="p">)]</span>
<span class="n">u_pred_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'u_pred.'</span><span class="p">)]</span>
<span class="n">u_mean</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">u_columns</span><span class="p">].</span><span class="n">mean</span><span class="p">().</span><span class="n">values</span>
<span class="n">u_pred_mean</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">u_pred_columns</span><span class="p">].</span><span class="n">mean</span><span class="p">().</span><span class="n">values</span>

<span class="n">pred_num</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">last_date</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'Month'</span><span class="p">].</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">future_months</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">last_date</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">pred_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s">'MS'</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

<span class="n">extended_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">future_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s">'Month'</span><span class="p">:</span> <span class="n">future_months</span><span class="p">})</span>
<span class="n">extended_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span><span class="n">extended_df</span><span class="p">,</span> <span class="n">future_df</span><span class="p">])</span>

<span class="n">extended_df</span><span class="p">[</span><span class="s">'fitted'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">u_mean</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">pred_num</span><span class="p">)])</span>
<span class="n">extended_df</span><span class="p">[</span><span class="s">'predicted'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)),</span> <span class="n">u_pred_mean</span><span class="p">[</span><span class="o">-</span><span class="n">pred_num</span><span class="p">:]])</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">extended_df</span><span class="p">[</span><span class="s">'Month'</span><span class="p">],</span> <span class="n">extended_df</span><span class="p">[</span><span class="s">'#Passengers'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Observed'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">extended_df</span><span class="p">[</span><span class="s">'Month'</span><span class="p">],</span> <span class="n">extended_df</span><span class="p">[</span><span class="s">'fitted'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Fitted'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">extended_df</span><span class="p">[</span><span class="s">'Month'</span><span class="p">],</span> <span class="n">extended_df</span><span class="p">[</span><span class="s">'predicted'</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Predicted'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'green'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Air Passengers: Observed, Fitted, and Predicted'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Date'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Number of Passengers'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>So, even though our model has a good in-sample fit, the out of sample predictions are very poor! We’ll have to do something about that!</p>

    </div>
</div>
        </div>
        
    </div>
</body>
</html>
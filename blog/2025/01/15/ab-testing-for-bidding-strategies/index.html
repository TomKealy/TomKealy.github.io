<!DOCTYPE html>
<html>
<head>
    <title>AB testing Google Ads Bidding strategies</title>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1' name='viewport'/>
    <meta name='description' content='Gregory Gundersen is a PhD candidate at Princeton.'>
    <meta name='keywords' content=''>
    <meta name='author' content='Gregory Gundersen'>
    
    <link href='/css/blog.css' rel='stylesheet'/>
    <link href='/css/trac.css' rel='stylesheet'/>
    <link href='/css/markdown.css' rel='stylesheet'/>
    
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>
    
    <script type='text/x-mathjax-config'>
MathJax.Hub.Config({
  jax: ['input/TeX', 'output/HTML-CSS'],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    extensions: ['color.js']
  },
  messageStyle: 'none',
  'HTML-CSS': { preferredFont: 'TeX', availableFonts: ['STIX','TeX'] }
});
</script>

<script src='//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML' type='text/javascript'></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
</head>
<body>
    <div class='content'>
        <div class='nav'>
    <ul class='wrap'>
        <li><a href='/'>Home</a></li>
        <li><a href='/blog'>Blog</a></li>
        <li><a href='/feed.xml'>RSS</a></li>
    </ul>
</div>
        <div class='front-matter'>
            <div class='wrap'>
                <h1>AB testing Google Ads Bidding strategies</h1>
                <h4></h4>
                <div class='bylines'>
                    <div class='byline'>
                        <h3>Published</h3>
                        <p>15 January 2025</p>
                    </div>
                </div>
                <div class='clear'></div>
            </div>
        </div>
        <div class='wrap article'>
            <ul><li><a href="#introduction">Introduction</a></li><li><a href="#data">Data</a></li><li><a href="#sequential-testing-by-betting-a-martingale-approach">Sequential Testing by Betting: A Martingale Approach</a><ul><li><a href="#a-general-two-sample-test">A General Two Sample test</a><ul><li><a href="#constructing-test-functions">Constructing test functions</a></li><li><a href="#betting-strategy">Betting strategy</a></li></ul></li></ul></li></ul>
            <h1 id="introduction">Introduction</h1>

<p>Google (and Meta, and Twitter) serves ads to users browsing the internet. For example, when you make a Google search, you will see sponsored content at the top of your search results. Similarly if you brose Instagram, some of the images you see will be products to buy. The ads you see when you are browsing the internet are paid for by companies who want you to buy their products. The companies bid, in automated auctions, for their ads to be served to you as you browse.</p>

<p>A <strong>bid</strong> is the amount of money you are willing to spend for a single click on a specific keyword in the Google Ads campaign. Those bids determine where your ads appear in search results. Bidders compete for the highest possible position in Google search rankings for the specific search query. Every time someone does a search in Google, the system runs all offers through Google’s algorithm and ranks the ads according to how much particular advertisers are willing to pay for that term as well as what is its quality score. In short, it is the auction that determines which ads will appear at that moment in that space and your bid puts you in the auction.</p>

<p>Google and Meta provide several ways to control the outcome of each auction: interested parties need to specify a target Return on Ad Spend (tROAS). This is the target ammount that you wish to make on each ad. For example, if a business spends 200 USD and this generates 1,000 USD in revenue (or conversion value), then the ROAS is 500%. Setting a tROAS of 500% says that the business needs to make 5 dollars for every dollar that’s spent on Google Ads.</p>

<p>Alternatively a company could control a target Cost per Acquisition (tCPA). Choosing a tCP Abidding strategy will generate the maximum number of conversions using a campaign’s budget. It will also account for the desired target cost per action, which is chosen by the advertiser. For example, if an advertiser has chosen a 20 USD Target CPA, Google will adjust bids to drive conversions and aim to achieve that tCPA.</p>

<p>So you can choose ROAS if you want the maximum conversion value per conversions for your ad budget. You can choose tCPA if you want the maximum number of conversion for a given ad budget.</p>

<p>Companies who bid for these ad spaces are interested in optimising their <strong>ad spend.</strong> That is would a ‘set and forget’ strategy—where you set a <em>fixed</em> tROAS value and leave it throughout a campaign—be outperformed by an adaptive strategy, where the tROAS is adjusted (possibly by an ML model) during the campaign. This is useful, because maybe you set the tCPA to bid 50 USD per conversion, buy you could have gotten away with paying 40 USE instead. A ‘set and forget it’ approach would therefore pay 10 USD extra, and over 1000s of conversions this strategy can cost millions extra over the course of a campaign.</p>

<p>One way to decide whether either strategy is better, is to conduct an A/B test. The challenge is that we cannot directly control the amount of money each strategy spends. The target determines the total spend, which in turn affects the number of conversions and ultimately, the return on investment (ROI). The only aspect I can control is the duration of the experiment. That is, conditioned on the history of outcomes, do I continue for another day?</p>

<p>Our goal is to determine whether the adaptive strategy can outperform the fixed strategy by at least 10\% in terms of ROI.</p>

<p>Here are a few key questions I have:</p>

<ol>
  <li>What is the appropriate randomisation unit in this case? We can’t be certain that the dollar ammounts or the number of conversions are at all comparible between experiment variations.</li>
  <li>Given the uncertainty over the randomisation unit, is the simple total profit (revenue - spend) an appropriate metric to determine the outcome of the experiment? What is an appropriate method for statistical inference in this case.</li>
  <li>Sample size &amp; duration: How do I determine the appropriate sample size or experiment duration to detect a 10% uplift in ROI with statistical significance? Is it even correct to think of randomisation units being days?</li>
  <li>Variance estimation: Given that spend is not directly controlled but influenced by target CPA, what metrics or techniques should I use to accurately estimate the variance in ROI across both groups?</li>
  <li>Bias mitigation: How can I account for differences in spend or conversion patterns that might create bias, especially if one strategy adapts faster than the other?</li>
  <li>Stopping rules: Since I can only control how long the experiment runs, what would be appropriate stopping criteria or statistical tests to apply during and after the experiment to ensure the results are reliable?</li>
</ol>

<h1 id="data">Data</h1>

<p>Google and Facebook collect data about each ad which is served to you. So, the data is at the level of the impression. I.e. each time somebody sees see an ad, that is recorded as a separate event. This means that a single person could see the same ad multiple times before clicking through (if they ever do so).</p>

<h1 id="sequential-testing-by-betting-a-martingale-approach">Sequential Testing by Betting: A Martingale Approach</h1>

<p>We are interested in testing which of two hypoteses are true:</p>

<ol>
  <li>The null hypothesis $H_0: P \in \mathcal{P}_{\text{null}}$.</li>
  <li>The alternative $H_1: P \in \mathcal{P}_{\text{alt}}$.</li>
</ol>

<p>We have observations of some procces denoted by $Z_1, Z_2, \ldots$ lying in some space $\mathcal{Z}$, and drawn i.i.d. according to $P$.</p>

<p>Testing by betting reframes hypothesis testing into a gambilng problem, instead of creating a function to produce test statistics. Totest the null $H_0$, a bettor may place repeated bets on the outcomes ${Z_t : t \geq 1}$ starting with an initial wealth $K_0 = 1$.</p>

<p>A single round of betting (say at time $t$) involves the following two steps:</p>

<p>Firstly, the bettor selects a payoff function $S_t: \mathcal{Z} \to [0, \infty)$. The payoff has to satisfy $\mathbb{E}<em>P[S_t(Z_t) \mid \mathcal{F}</em>{t-1}] = 1$. I.e. the bet is fair when the null is true. Then, the outcome $Z_t$ is revealed, and the bettor’s wealth grows (or possibly shrinks) by a factor of $S_t(Z_t)$. Thus, the bettor’s wealth after $t$ rounds of betting is $K_t = K_0 \prod_{i=1}^t S_i(Z_i)$.</p>

<p>The restriction on the conditional expectation of the payoff functions implies that under the null, ${K_t : t \geq 0}$ is a nonnegative martingale with an initial value 1. Due to this fact, $K_t$ is unlikely to take large values for any $t \geq 1$.</p>

<p>On the other hand, when $H_1$ is true, the bettor’s choice of payoff functions, ${S_t : t \geq 1}$ should ensure that the wealth process grows exponentially. Such a wealth process naturally leads to the following sequential test: reject the null if $K_t \geq 1/\alpha$, where $\alpha \in (0, 1)$ is the desired confidence level. Ville’s maximal inequality([^1]) ensures that this test controls the type-I error at level $\alpha$.</p>

<p>When testing simple hypotheses ($H_0: Z_t \sim P$ and $H_1: Z_t \sim Q$ with $P$ and $Q$ known), the payoff fucntion $S_t$ is just the likelihood ratio $Q/P$. With this choice of payoff functions, we have:</p>

\[\mathbb{E}_P\left[S_t \mid \mathcal{F}_{t-1}\right] = 1\]

<p>meaning it is a fair bet under the null. Under $H_1$, the wealth process with this payoff grows exponentially, with an optimal (expected) growth rate of $\text{KL}(Q, P)$: the KL-divergence between $Q$ and $P$.</p>

<p>When dealing with cases where either one or both of $H_0$ and $H_1$ are composite and nonparametric there is no obvious choice for the payoff functions. So there are a couple of design choices we need to make before we can use the testing by betting framework:</p>

<ol>
  <li>In which function class should $S_t$ lie?</li>
  <li>How to ensure $\mathbb{E}\left[S_t \mid \mathcal{F}<em>{t-1}\right] = 1$ uniformly over $\mathcal{P}</em>{\text{null}}$?</li>
  <li>How to ensure fast growth of $K_t$ under the alternative?</li>
</ol>

<p>Before we continue with the exposition, we first define a sequential test:</p>

<blockquote>
  <p><strong>Definition 1</strong> (sequential-test). A level-$\alpha$ sequential test can be represented by a random stopping time $\tau$ taking values in ${1, 2, \ldots} \cup {\infty}$, and satisfying the condition $\mathbb{P}(\tau &lt; \infty) \leq \alpha$, under the null $H_0$. Thus, $\tau$ denotes the random time at which the null hypothesis is rejected.</p>
</blockquote>

<h2 id="a-general-two-sample-test">A General Two Sample test</h2>

<p>We begin by defining the two-sample testing problem.</p>

<p><strong>Definition:Two-sample testing.</strong> Given a stream of paired observations ${(X_t,Y_t) : t \geq 1}$, drawn i.i.d. according to $P_X \times P_Y$ on the observation space $\mathcal{X} \times \mathcal{X}$, our goal is to test the null, $H_0 : P_X = P_Y$ against the alternative  $H_0 : P_X \neq P_Y$.</p>

<p>The distributions in the null class are invariant to the action of the operator $T : (\mathcal{X} \times \mathcal{X}) \to (\mathcal{X} \times \mathcal{X})$ that takes elements $(x,y) \in \mathcal{X} \times \mathcal{X}$ and flips their order; that is $T(x,y) = (y,x)$.</p>

<blockquote>
  <p><strong>Remark</strong> This definition assumes two streams of i.i.d. observations, ${X_t : t \geq 1}$ and ${Y_t : t \geq 1}$. However, <a class="citation" href="#shekhar2023nonparametric">(Shekhar &amp; Ramdas, 2023)</a> prove a theorem whose results are valid under a much weaker assumption that the stream ${(X_t,Y_t) : t \geq 1}$ consists of independent pairs of observations satisfying $(X_t,Y_t) \stackrel{d}{=} (Y_t, X_t)$ under the null, and $(X_t,Y_t) \stackrel{d}{\neq} (Y_t,X_t)$ under the alternative.</p>
</blockquote>

<p>This means we only need:</p>

<ul>
  <li>Each day’s comparison to be a fair test under the null</li>
  <li>The betting strategy to only use past information</li>
</ul>

<p>We don’t need full independence between days, which makes this approach particularly suitable for our adaptive bidding scenario.</p>

<p>Now we need to do two things:</p>

<ol>
  <li>Construct a test function.</li>
  <li>Choose a betting strategy.</li>
</ol>

<h3 id="constructing-test-functions">Constructing test functions</h3>

<p>{cite % shekhar2023nonparametric %} begin by choosing a distance measure on the space of probability distributions which admits a variational representation. Specifically the function must be part of a class of functions $\mathbb{G}$ which maxmises the following distance:</p>

\[dG\left(P, Q\right) = sup_{g∈G} \midEP[g(X)] - EQ[g(Y)]\mid\]

<p>The function class $G$ should contain functions mapping to $\left[-1/2, 1/2\right]$. {cite % shekhar2023nonparametric %} choose a specific class of functions $G$ using the kernel maximum mean discrepancy (MMD) metric defined below:</p>

<p><strong>Definition (kernel MMD)</strong> Let $\mathcal{X}$ denote the observation space, which for simplicity, we set to $\mathbb{R}^m$ for some $m \geq 1$, and let $K : \mathcal{X} \times \mathcal{X} \to \mathbb{R}$ be a positive definite kernel on $\mathcal{X}$. We assume that $K$ is uniformly bounded, that is, $\sup_{x,x’\in\mathcal{X}} K(x, x’) \leq 1$, and let $\mathcal{H}_K$ denote the reproducing kernel Hilbert space (RKHS) associated with $K$.</p>

<p>The associated IPM, called the kernel-MMD metric, is defined as follows:</p>

<p>$d_{MMD}(P, Q) = \sup_{|g|_K \leq 1} \mathbb{E}_P[g(X)] - \mathbb{E}_Q[g(Y)]$</p>

<p>where $|g|<em>K$ denotes the RKHS norm of the function $g$. The mean map of a distribution $P$ is a function in the RKHS given by $\mu_P := \mathbb{E}_P[K(X, \cdot)]$. When $P \neq Q$, the “witness” function $h^*$ that achieves the supremum in $d</em>{MMD}(P,Q)$ (i.e. witnesses the difference between $P,Q$) is simply given by $h^* := \mu_P - \mu_Q$, meaning that $d_{MMD}(P, Q) = \mathbb{E}_P[h^<em>(X)] - \mathbb{E}_Q[h^</em>(Y)]$.</p>

<p>and $g^* = \frac{1}{2}h^*$.</p>

<p>A predictor playing ${g_t : t \geq 1}$ is $|\mu_P - \mu_Q|_K$.</p>

<p>The above discussion suggests the choice of $\mathcal{G} = {g \in \mathcal{H}_K : |g| \leq 1/2}$</p>

<p>$\tilde{g}(x,y) = g^<em>(x) - g^</em>(y) = \langle g^*, K(x,\cdot) - K(y,\cdot)\rangle$</p>

<p>Note that the scaling $h$ by $1/2$ in the definition of $g$ ensures that $\tilde{g}$ takes values in $[-1, 1]$.</p>

<p>This is implemented in the following code block (based upon the author’s <a href="https://github.com/sshekhar17/nonparametric-testing-by-betting">own implementation</a>):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">compute_mmd</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">Y</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">kernel</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="s">"""
    Compute Maximum Mean Discrepancy (MMD) between X and Y samples.
    
    As described in paper Section 4: "Sequential Two-Sample Kernel-MMD Test",
    MMD is computed as:
    MMD^2(P,Q) = E[k(X,X')] + E[k(Y,Y')] - 2E[k(X,Y)]
    where k is the kernel function.
    
    Args:
        X: First sample set 
        Y: Second sample set
        kernel: Kernel function k(x,y)
        
    Returns:
        float: MMD^2 value
    """</span>
    <span class="c1"># Compute kernel matrices
</span>    <span class="n">Kxx</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># k(X,X)
</span>    <span class="n">Kyy</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>  <span class="c1"># k(Y,Y)
</span>    <span class="n">Kxy</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>  <span class="c1"># k(X,Y)
</span>    
    <span class="c1"># Compute expectations
</span>    <span class="c1"># Note: We exclude diagonal elements for Kxx and Kyy as they represent k(x,x)
</span>    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">Y</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Kxx</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Kxx</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># E[k(X,X')] 
</span>    <span class="n">yy</span> <span class="o">=</span> <span class="p">(</span><span class="n">Kyy</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Kyy</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># E[k(Y,Y')]
</span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">Kxy</span><span class="p">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># E[k(X,Y)]
</span>    
    <span class="c1"># Compute MMD^2
</span>    <span class="n">mmd2</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">xy</span>
    
    <span class="k">return</span> <span class="n">mmd2</span>

<span class="k">def</span> <span class="nf">kernel_mmd_prediction</span><span class="p">(</span><span class="n">Xt</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">Yt</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
                         <span class="n">kernel</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                         <span class="n">post_processing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">'clip'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="s">"""
    Compute MMD prediction for sequential testing using selected kernel.
    
    As discussed in paper Section 4, this implements the witness function
    associated with kernel-MMD for testing.
    
    Args:
        Xt: Current batch X samples
        Yt: Current batch Y samples
        kernel: Kernel function
        post_processing: How to constrain output ('clip' or 'tanh')
        
    Returns:
        tuple: (prediction, metadata)
    """</span>
    <span class="c1"># Compute centered kernel matrices
</span>    <span class="n">Kxx</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
    <span class="n">Kyy</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">Yt</span><span class="p">)</span>
    <span class="n">Kxy</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">Xt</span><span class="p">,</span> <span class="n">Yt</span><span class="p">)</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Yt</span><span class="p">)</span>
    
    <span class="c1"># Compute witness function values
</span>    <span class="n">wx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Kxx</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Kxx</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">wy</span> <span class="o">=</span> <span class="n">Kxy</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
    <span class="n">witness_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">wx</span> <span class="o">-</span> <span class="n">wy</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
    
    <span class="n">wy</span> <span class="o">=</span> <span class="p">(</span><span class="n">Kyy</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Kyy</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">wx</span> <span class="o">=</span> <span class="n">Kxy</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>  
    <span class="n">witness_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">wy</span> <span class="o">-</span> <span class="n">wx</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
    
    <span class="c1"># Normalize predictions to [-1/2, 1/2] range as required by betting
</span>    <span class="k">if</span> <span class="n">post_processing</span> <span class="o">==</span> <span class="s">'clip'</span><span class="p">:</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">witness_x</span><span class="p">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">witness_y</span><span class="p">.</span><span class="n">mean</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">post_processing</span> <span class="o">==</span> <span class="s">'tanh'</span><span class="p">:</span>
        <span class="c1"># Use tanh for unbounded kernels as described in Section 2.3
</span>        <span class="n">prediction</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">witness_x</span><span class="p">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">witness_y</span><span class="p">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s">"Unknown post_processing: </span><span class="si">{</span><span class="n">post_processing</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'witness_x'</span><span class="p">:</span> <span class="n">witness_x</span><span class="p">,</span>
        <span class="s">'witness_y'</span><span class="p">:</span> <span class="n">witness_y</span><span class="p">,</span>
        <span class="s">'mmd2'</span><span class="p">:</span> <span class="n">compute_mmd</span><span class="p">(</span><span class="n">Xt</span><span class="p">,</span> <span class="n">Yt</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">metadata</span>

<span class="k">def</span> <span class="nf">get_optimal_kernel_bandwidth</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
                               <span class="n">Y</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="s">"""
    Get optimal bandwidth for RBF kernel using median heuristic.
    
    As referenced in the paper's experiments section.
    
    Args:
        X: First sample set
        Y: Second sample set
        
    Returns:
        float: Optimal bandwidth
    """</span>
    <span class="c1"># Combine samples
</span>    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">])</span>
    
    <span class="c1"># Compute pairwise distances
</span>    <span class="n">dists</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="s">'euclidean'</span><span class="p">)</span>
    
    <span class="c1"># Use median heuristic
</span>    <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">triu_indices_from</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>
    
    <span class="k">return</span> <span class="n">bandwidth</span>
</code></pre></div></div>

<p>For our problem, we are interested in calculating the relative ROI of two bidding strategies on Google Smart Bidding. So we can use the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">ROIMetrics</span><span class="p">:</span>
    <span class="n">revenue</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">spend</span><span class="p">:</span> <span class="nb">float</span>
    
    <span class="k">def</span> <span class="nf">roi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">revenue</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">spend</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">spend</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>

<span class="k">class</span> <span class="nc">ROIKernelMMDTest</span><span class="p">:</span>
    <span class="s">"""
    Kernel MMD test for ROI comparisons using betting martingales.
    Combines ROI witness function with kernel MMD framework from paper.
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                <span class="n">kernel_bandwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                <span class="n">min_effect</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.10</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">kernel_bandwidth</span> <span class="o">=</span> <span class="n">kernel_bandwidth</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">min_effect</span> <span class="o">=</span> <span class="n">min_effect</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">wealth_history</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">compute_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ROIMetrics</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ROIMetrics</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">"""
        Compute kernel between two ROI values using RBF kernel.
        """</span>
        <span class="n">roi_diff</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">roi</span><span class="p">()</span> <span class="o">-</span> <span class="n">y</span><span class="p">.</span><span class="n">roi</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">roi_diff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">kernel_bandwidth</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">compute_mmd_squared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                          <span class="n">adaptive_samples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">],</span>
                          <span class="n">fixed_samples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">"""
        Compute squared MMD between adaptive and fixed strategy samples.
        
        MMD^2 = E[k(x,x')] + E[k(y,y')] - 2E[k(x,y)] 
        where k is the kernel function
        """</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adaptive_samples</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_samples</span><span class="p">)</span>

        <span class="c1"># Compute kernel matrices
</span>        <span class="n">K_aa</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">K_ff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">K_af</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">K_aa</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_kernel</span><span class="p">(</span><span class="n">adaptive_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adaptive_samples</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">K_af</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_kernel</span><span class="p">(</span><span class="n">adaptive_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fixed_samples</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">K_ff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_kernel</span><span class="p">(</span><span class="n">fixed_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fixed_samples</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1"># Compute expectations (excluding diagonal elements where appropriate)
</span>        <span class="n">E_aa</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_aa</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">trace</span><span class="p">(</span><span class="n">K_aa</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">E_ff</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_ff</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">trace</span><span class="p">(</span><span class="n">K_ff</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">E_af</span> <span class="o">=</span> <span class="n">K_af</span><span class="p">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="n">mmd_squared</span> <span class="o">=</span> <span class="n">E_aa</span> <span class="o">+</span> <span class="n">E_ff</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">E_af</span>
        <span class="k">return</span> <span class="n">mmd_squared</span>

    <span class="k">def</span> <span class="nf">compute_witness_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">adaptive_metrics</span><span class="p">:</span> <span class="n">ROIMetrics</span><span class="p">,</span>
                            <span class="n">fixed_metrics</span><span class="p">:</span> <span class="n">ROIMetrics</span><span class="p">,</span>
                            <span class="n">adaptive_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">],</span>
                            <span class="n">fixed_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">"""
        Compute witness function value for sequential testing.
        Maps to [-1/2, 1/2] range as required by betting strategy.
        """</span>
        <span class="c1"># Compute ROI difference
</span>        <span class="n">roi_diff</span> <span class="o">=</span> <span class="n">adaptive_metrics</span><span class="p">.</span><span class="n">roi</span><span class="p">()</span> <span class="o">-</span> <span class="n">fixed_metrics</span><span class="p">.</span><span class="n">roi</span><span class="p">()</span>
        
        <span class="c1"># Weight by kernel-based similarity to historical data
</span>        <span class="n">kernel_weight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">n_hist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adaptive_history</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_hist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hist_a</span><span class="p">,</span> <span class="n">hist_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adaptive_history</span><span class="p">,</span> <span class="n">fixed_history</span><span class="p">):</span>
                <span class="n">k_a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_kernel</span><span class="p">(</span><span class="n">adaptive_metrics</span><span class="p">,</span> <span class="n">hist_a</span><span class="p">)</span>
                <span class="n">k_f</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_kernel</span><span class="p">(</span><span class="n">fixed_metrics</span><span class="p">,</span> <span class="n">hist_f</span><span class="p">)</span>
                <span class="n">kernel_weight</span> <span class="o">+=</span> <span class="p">(</span><span class="n">k_a</span> <span class="o">-</span> <span class="n">k_f</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_hist</span>

        <span class="c1"># Combine direct ROI difference with kernel-weighted historical influence
</span>        <span class="n">witness</span> <span class="o">=</span> <span class="n">roi_diff</span> <span class="o">+</span> <span class="n">kernel_weight</span>
        
        <span class="c1"># Map to [-1/2, 1/2] using tanh
</span>        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">witness</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">adaptive_metrics</span><span class="p">:</span> <span class="n">ROIMetrics</span><span class="p">,</span>
              <span class="n">fixed_metrics</span><span class="p">:</span> <span class="n">ROIMetrics</span><span class="p">,</span>
              <span class="n">adaptive_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">],</span>
              <span class="n">fixed_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="s">"""
        Update test statistics and check stopping condition.
        
        Returns:
            Tuple of (should_stop, decision)
        """</span>
        <span class="c1"># Compute witness value
</span>        <span class="n">witness</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_witness_value</span><span class="p">(</span>
            <span class="n">adaptive_metrics</span><span class="p">,</span>
            <span class="n">fixed_metrics</span><span class="p">,</span> 
            <span class="n">adaptive_history</span><span class="p">,</span>
            <span class="n">fixed_history</span>
        <span class="p">)</span>
        
        <span class="c1"># Compute optimal bet size (Kelly fraction)
</span>        <span class="n">relative_improvement</span> <span class="o">=</span> <span class="p">(</span><span class="n">adaptive_metrics</span><span class="p">.</span><span class="n">roi</span><span class="p">()</span> <span class="o">-</span> <span class="n">fixed_metrics</span><span class="p">.</span><span class="n">roi</span><span class="p">())</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fixed_metrics</span><span class="p">.</span><span class="n">roi</span><span class="p">())</span> <span class="k">if</span> <span class="n">fixed_metrics</span><span class="p">.</span><span class="n">roi</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">bet</span> <span class="o">=</span> <span class="p">(</span><span class="n">relative_improvement</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">min_effect</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">bet</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bet</span><span class="p">))</span>
        
        <span class="c1"># Update wealth
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">bet</span> <span class="o">*</span> <span class="n">witness</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">wealth_history</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">wealth</span><span class="p">)</span>

        <span class="c1"># Check stopping conditions
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="s">"Reject null - Adaptive strategy shows significant improvement"</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="s">"Accept null - Insufficient evidence for improvement"</span>
        
        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="s">"Continue testing"</span>

<span class="k">def</span> <span class="nf">run_roi_mmd_experiment</span><span class="p">(</span>
    <span class="n">adaptive_metrics</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">],</span>
    <span class="n">fixed_metrics</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ROIMetrics</span><span class="p">],</span>
    <span class="n">kernel_bandwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">min_effect</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.10</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="s">"""
    Run complete ROI MMD experiment.
    
    Args:
        adaptive_metrics: List of metrics from adaptive strategy
        fixed_metrics: List of metrics from fixed strategy
        kernel_bandwidth: Kernel sensitivity parameter
        alpha: Type I error rate
        min_effect: Minimum ROI improvement to detect
        
    Returns:
        Dict containing test results and metrics
    """</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">ROIKernelMMDTest</span><span class="p">(</span>
        <span class="n">kernel_bandwidth</span><span class="o">=</span><span class="n">kernel_bandwidth</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">min_effect</span><span class="o">=</span><span class="n">min_effect</span>
    <span class="p">)</span>
    
    <span class="n">n_days</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adaptive_metrics</span><span class="p">)</span>
    <span class="n">stopped</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">stop_day</span> <span class="o">=</span> <span class="n">n_days</span>
    <span class="n">decision</span> <span class="o">=</span> <span class="s">"Inconclusive"</span>
    
    <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_days</span><span class="p">):</span>
        <span class="c1"># Get current day metrics
</span>        <span class="n">adaptive</span> <span class="o">=</span> <span class="n">adaptive_metrics</span><span class="p">[</span><span class="n">day</span><span class="p">]</span>
        <span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed_metrics</span><span class="p">[</span><span class="n">day</span><span class="p">]</span>
        
        <span class="c1"># Get history up to current day
</span>        <span class="n">adaptive_history</span> <span class="o">=</span> <span class="n">adaptive_metrics</span><span class="p">[:</span><span class="n">day</span><span class="p">]</span>
        <span class="n">fixed_history</span> <span class="o">=</span> <span class="n">fixed_metrics</span><span class="p">[:</span><span class="n">day</span><span class="p">]</span>
        
        <span class="c1"># Update test
</span>        <span class="n">should_stop</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">adaptive</span><span class="p">,</span>
            <span class="n">fixed</span><span class="p">,</span>
            <span class="n">adaptive_history</span><span class="p">,</span>
            <span class="n">fixed_history</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">should_stop</span><span class="p">:</span>
            <span class="n">stopped</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">stop_day</span> <span class="o">=</span> <span class="n">day</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">decision</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">break</span>
            
    <span class="c1"># Compute final MMD
</span>    <span class="n">final_mmd</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">compute_mmd_squared</span><span class="p">(</span><span class="n">adaptive_metrics</span><span class="p">,</span> <span class="n">fixed_metrics</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'stopped'</span><span class="p">:</span> <span class="n">stopped</span><span class="p">,</span>
        <span class="s">'stop_day'</span><span class="p">:</span> <span class="n">stop_day</span><span class="p">,</span>
        <span class="s">'decision'</span><span class="p">:</span> <span class="n">decision</span><span class="p">,</span>
        <span class="s">'final_mmd'</span><span class="p">:</span> <span class="n">final_mmd</span><span class="p">,</span>
        <span class="s">'wealth_history'</span><span class="p">:</span> <span class="n">test</span><span class="p">.</span><span class="n">wealth_history</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="betting-strategy">Betting strategy</h3>

<p>Having selected $\mathcal{G}$, the final step in instantiating the sequential test is choosing an appropriate prediction strategy. The regret of the prediction game after $n$ observations is:</p>

<p>$R_n \equiv R_n(A_{pred}, \mathcal{G}, X_1^n, Y_1^n) = \max_{g \in \mathcal{G}} \sum_{t=1}^n \langle g - g_t, K(X_t,\cdot) - K(Y_t,\cdot)\rangle.$</p>

<p>A natural choice is the plug-in or the empirical risk minimization (ERM) strategy, that simply selects $g_t = \arg\max_{g\in\mathcal{G}}\langle g,\mu_{\hat{P}<em>{X,t-1}} - \mu</em>{\hat{P}_{Y,t-1}}\rangle$. We can check that this choice results in a consistent sequential test.</p>

<p>To get the exponent and bound on the expected stopping time under the alternative, however, we need to use an adaptive version of the online gradient ascent (OGA) strategy, that proceeds as follows, with $M_t := \sum_{i=1}^t |g_i(X_i, \cdot) - g_i(Y_i, \cdot)|^2_K$:</p>

<p>$g_1 = 0, \text{ and } g_{t+1} = \Pi_{\mathcal{G}}\left(g_t + \frac{1}{2\sqrt{M_t}}(K(X_t,\cdot) - K(Y_t,\cdot))\right) \text{ for } t \geq 1. \tag{17}$</p>

<p>Recall that $\Pi_{\mathcal{G}}$ denotes the projection operator (in terms of the RKHS norm $|\cdot|<em>K$) onto the function class $\mathcal{G}$, which acts as follows: $\Pi</em>{\mathcal{G}}(h) = \frac{h}{2|h|_K}$.</p>

<p><strong>Definition: Sequential Kernel MMD Test:</strong></p>

<p>Set $K_0 = 1$, $\lambda_1 = 0$, and $g_1 = 0 \in \mathcal{H}_K$. For $t = 1,2,…$:</p>

<ul>
  <li>Observe $X_t$, $Y_t$</li>
  <li>Update the wealth: $K_t = K_{t-1} \times (1 + \lambda_t\langle g_t, K(X_t, \cdot) - K(Y_t, \cdot)\rangle)$</li>
  <li>Reject the null if $K_t \geq 1/\alpha$</li>
  <li>Update $g_{t+1}$ using the OGA prediction strategy described above</li>
  <li>Update $\lambda_{t+1}$ as follows:</li>
</ul>

<p>$\lambda_{t+1} = \min{1,\max{-1,\lambda_t - \frac{2z_t}{2-\log_3a_t^2}}}$</p>

<p>The full MMD Test is in the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="k">class</span> <span class="nc">SequentialKernelMMDTest</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">kernel_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">):</span>
        <span class="s">"""
        Sequential Kernel MMD Test as defined in paper Definition 8.
        
        Args:
            kernel_func: Kernel function k(x,y)
            alpha: Type I error rate
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel_func</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        
        <span class="c1"># Initialize test statistics
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">K0</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Kt</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Current wealth
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">wealth_history</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        
        <span class="c1"># Initialize betting strategy
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">lambda1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">lambda_t</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">a0</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># For ONS strategy
</span>        
        <span class="c1"># Initialize prediction strategy
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">g1</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">gt</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Mt</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Sum of squared RKHS norms
</span>        
    <span class="k">def</span> <span class="nf">_ons_betting_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">"""
        Online Newton Step betting strategy (Definition 5 in paper).
        """</span>
        <span class="c1"># Update at based on zt
</span>        <span class="n">zt</span> <span class="o">=</span> <span class="n">vt</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">vt</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">lambda_t</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">a0</span> <span class="o">+=</span> <span class="n">zt</span> <span class="o">*</span> <span class="n">zt</span>
        
        <span class="c1"># Update lambda using ONS update rule
</span>        <span class="n">lambda_next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">lambda_t</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="n">zt</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">a0</span>
        
        <span class="c1"># Project to [-1/2, 1/2]
</span>        <span class="n">lambda_next</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lambda_next</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">lambda_next</span>
    
    <span class="k">def</span> <span class="nf">_oga_prediction_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                             <span class="n">Xt</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
                             <span class="n">Yt</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
                             <span class="n">kt_x</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">kt_y</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="s">"""
        Online Gradient Ascent prediction strategy (Equation 17 in paper).
        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">gt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">gt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">kt_x</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">gt</span>
            
        <span class="c1"># Compute RKHS norm of difference
</span>        <span class="n">diff</span> <span class="o">=</span> <span class="n">kt_x</span> <span class="o">-</span> <span class="n">kt_y</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Mt</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span>
        
        <span class="c1"># Update using OGA
</span>        <span class="n">grad</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">Mt</span><span class="p">))</span>
        <span class="n">gt_new</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">gt</span> <span class="o">+</span> <span class="n">grad</span>
        
        <span class="c1"># Project onto G using RKHS norm
</span>        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">gt_new</span> <span class="o">*</span> <span class="n">gt_new</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gt_new</span> <span class="o">=</span> <span class="n">gt_new</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">norm</span><span class="p">)</span>  <span class="c1"># ΠG operator
</span>            
        <span class="k">return</span> <span class="n">gt_new</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
               <span class="n">Xt</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">Yt</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="s">"""
        Update test statistics for new observations.
        
        Args:
            Xt: New X observation
            Yt: New Y observation
            
        Returns:
            (should_stop, decision)
        """</span>
        <span class="c1"># Compute kernel evaluations
</span>        <span class="n">kt_x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
        <span class="n">kt_y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Yt</span><span class="p">)</span>
        
        <span class="c1"># Update prediction gt+1 using OGA
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">gt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_oga_prediction_update</span><span class="p">(</span><span class="n">Xt</span><span class="p">,</span> <span class="n">Yt</span><span class="p">,</span> <span class="n">kt_x</span><span class="p">,</span> <span class="n">kt_y</span><span class="p">)</span>
        
        <span class="c1"># Compute test statistic
</span>        <span class="n">vt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">gt</span><span class="p">,</span> <span class="p">(</span><span class="n">kt_x</span> <span class="o">-</span> <span class="n">kt_y</span><span class="p">))</span>
        
        <span class="c1"># Update wealth
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">Kt</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">lambda_t</span> <span class="o">*</span> <span class="n">vt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">wealth_history</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">Kt</span><span class="p">)</span>
        
        <span class="c1"># Update betting fraction λt+1 using ONS
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">lambda_t</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_ons_betting_update</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span>
        
        <span class="c1"># Check stopping condition
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">Kt</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="p">.</span><span class="n">alpha</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="s">"Reject null hypothesis - Distributions differ significantly"</span>
        
        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="s">"Continue testing"</span>
        
    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="s">"""Get test results."""</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s">'stopped'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">Kt</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="p">.</span><span class="n">alpha</span><span class="p">,</span>
            <span class="s">'wealth'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">Kt</span><span class="p">,</span>
            <span class="s">'wealth_history'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth_history</span><span class="p">,</span>
            <span class="s">'lambda_final'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">lambda_t</span>
        <span class="p">}</span>

<span class="k">def</span> <span class="nf">run_sequential_mmd_test</span><span class="p">(</span><span class="n">X_stream</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">Y_stream</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">kernel_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                           <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                           <span class="n">max_samples</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="s">"""
    Run sequential kernel MMD test on two sample streams.
    
    Args:
        X_stream: First sample stream 
        Y_stream: Second sample stream
        kernel_func: Kernel function
        alpha: Type I error rate
        max_samples: Maximum samples to test (optional)
        
    Returns:
        Dict containing test results
    """</span>
    <span class="c1"># Initialize test
</span>    <span class="n">test</span> <span class="o">=</span> <span class="n">SequentialKernelMMDTest</span><span class="p">(</span><span class="n">kernel_func</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    
    <span class="c1"># Set max samples
</span>    <span class="k">if</span> <span class="n">max_samples</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">max_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_stream</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_stream</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y_stream</span><span class="p">),</span> <span class="n">max_samples</span><span class="p">)</span>
    
    <span class="c1"># Run sequential test
</span>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">X_stream</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">Yt</span> <span class="o">=</span> <span class="n">Y_stream</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        
        <span class="n">should_stop</span><span class="p">,</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">Xt</span><span class="p">,</span> <span class="n">Yt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">should_stop</span><span class="p">:</span>
            <span class="k">break</span>
            
    <span class="c1"># Get results
</span>    <span class="n">results</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">get_results</span><span class="p">()</span>
    <span class="n">results</span><span class="p">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s">'samples_used'</span><span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s">'decision'</span><span class="p">:</span> <span class="n">decision</span>
    <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">results</span>
</code></pre></div></div>

        </div>
        
    </div>
</body>
</html>
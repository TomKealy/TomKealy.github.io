<!DOCTYPE html>
<html>
<head>
    <title>AB testing Google Ads Bidding strategies</title>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1' name='viewport'/>
    <meta name='description' content='Gregory Gundersen is a PhD candidate at Princeton.'>
    <meta name='keywords' content=''>
    <meta name='author' content='Gregory Gundersen'>
    
    <link href='/css/blog.css' rel='stylesheet'/>
    <link href='/css/trac.css' rel='stylesheet'/>
    <link href='/css/markdown.css' rel='stylesheet'/>
    
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>
    
    <script type='text/x-mathjax-config'>
MathJax.Hub.Config({
  jax: ['input/TeX', 'output/HTML-CSS'],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    extensions: ['color.js']
  },
  messageStyle: 'none',
  'HTML-CSS': { preferredFont: 'TeX', availableFonts: ['STIX','TeX'] }
});
</script>

<script src='//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML' type='text/javascript'></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
</head>
<body>
    <div class='content'>
        <div class='nav'>
    <ul class='wrap'>
        <li><a href='/'>Home</a></li>
        <li><a href='/blog'>Blog</a></li>
        <li><a href='/feed.xml'>RSS</a></li>
    </ul>
</div>
        <div class='front-matter'>
            <div class='wrap'>
                <h1>AB testing Google Ads Bidding strategies</h1>
                <h4></h4>
                <div class='bylines'>
                    <div class='byline'>
                        <h3>Published</h3>
                        <p>15 January 2025</p>
                    </div>
                </div>
                <div class='clear'></div>
            </div>
        </div>
        <div class='wrap article'>
            <h1 id="introduction">Introduction</h1>

<p>Google (and Meta, and Twitter) serves ads to users browsing the internet. For example, when you make a Google search, you will see sponsored content at the top of your search results. Similarly if you brose Instagram, some of the images you see will be products to buy. The ads you see when you are browsing the internet are paid for by companies who want you to buy their products. The companies bid, in automated auctions, for their ads to be served to you as you browse.</p>

<p>A <strong>bid</strong> is the amount of money you are willing to spend for a single click on a specific keyword in the Google Ads campaign. Those bids determine where your ads appear in search results. Bidders compete for the highest possible position in Google search rankings for the specific search query. Every time someone does a search in Google, the system runs all offers through Google’s algorithm and ranks the ads according to how much particular advertisers are willing to pay for that term as well as what is its quality score. In short, it is the auction that determines which ads will appear at that moment in that space and your bid puts you in the auction.</p>

<p>Google and Meta provide several ways to control the outcome of each auction: interested parties need to specify a target Return on Ad Spend (tROAS). This is the target ammount that you wish to make on each ad. For example, if a business spends 200 USD and this generates 1,000 USD in revenue (or conversion value), then the ROAS is 500%. Setting a tROAS of 500% says that the business needs to make 5 dollars for every dollar that’s spent on Google Ads.</p>

<p>Alternatively a company could control a target Cost per Acquisition (tCPA). Choosing a tCP Abidding strategy will generate the maximum number of conversions using a campaign’s budget. It will also account for the desired target cost per action, which is chosen by the advertiser. For example, if an advertiser has chosen a 20 USD Target CPA, Google will adjust bids to drive conversions and aim to achieve that tCPA.</p>

<p>So you can choose ROAS if you want the maximum conversion value per conversions for your ad budget. You can choose tCPA if you want the maximum number of conversion for a given ad budget.</p>

<p>Companies who bid for these ad spaces are interested in optimising their <strong>ad spend.</strong> That is would a ‘set and forget’ strategy—where you set a <em>fixed</em> tROAS value and leave it throughout a campaign—be outperformed by an adaptive strategy, where the tROAS is adjusted (possibly by an ML model) during the campaign. This is useful, because maybe you set the tCPA to bid 50 USD per conversion, buy you could have gotten away with paying 40 USE instead. A ‘set and forget it’ approach would therefore pay 10 USD extra, and over 1000s of conversions this strategy can cost millions extra over the course of a campaign.</p>

<p>One way to decide whether either strategy is better, is to conduct an A/B test. The challenge is that we cannot directly control the amount of money each strategy spends. The target determines the total spend, which in turn affects the number of conversions and ultimately, the return on investment (ROI). The only aspect I can control is the duration of the experiment. That is, conditioned on the history of outcomes, do I continue for another day?</p>

<p>Our goal is to determine whether the adaptive strategy can outperform the fixed strategy by at least 10\% in terms of ROI.</p>

<p>Here are a few key questions I have:</p>

<ol>
  <li>What is the appropriate randomisation unit in this case? We can’t be certain that the dollar ammounts or the number of conversions are at all comparible between experiment variations.</li>
  <li>Given the uncertainty over the randomisation unit, is the simple total profit (revenue - spend) an appropriate metric to determine the outcome of the experiment? What is an appropriate method for statistical inference in this case.</li>
  <li>Sample size &amp; duration: How do I determine the appropriate sample size or experiment duration to detect a 10% uplift in ROI with statistical significance? Is it even correct to think of randomisation units being days?</li>
  <li>Variance estimation: Given that spend is not directly controlled but influenced by target CPA, what metrics or techniques should I use to accurately estimate the variance in ROI across both groups?</li>
  <li>Bias mitigation: How can I account for differences in spend or conversion patterns that might create bias, especially if one strategy adapts faster than the other?</li>
  <li>Stopping rules: Since I can only control how long the experiment runs, what would be appropriate stopping criteria or statistical tests to apply during and after the experiment to ensure the results are reliable?</li>
</ol>

<h1 id="data">Data</h1>

<p>Google and Facebook collect data about each ad which is served to you. So, the data is at the level of the impression. I.e. each time somebody sees see an ad, that is recorded as a separate event. This means that a single person could see the same ad multiple times before clicking through (if they ever do so).</p>

<h1 id="sequential-testing-by-betting-a-martingale-approach">Sequential Testing by Betting: A Martingale Approach</h1>

<p>We are interested in testing which of two hypoteses are true: a null hypothesis $H_0: P \in \mathcal{P}<em>{\text{null}}$ and alternative $H_1: P \in \mathcal{P}</em>{\text{alt}}$. We have observations denoted by $Z_1, Z_2, \ldots$ lying in some space $\mathcal{Z}$, and drawn i.i.d. according to $P$.</p>

<p>Testing by betting reframes hypothesis testing into a gambilng problem, instead of creating a function to produce test statistics. Totest the null $H_0$, a bettor may place repeated bets on the outcomes ${Z_t : t \geq 1}$ starting with an initial wealth $K_0 = 1$. A single round of betting (say at time $t$) involves the following two steps:</p>

<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>First, the bettor selects a payoff function $S_t: \mathcal{Z} \to [0, \infty)$, under the restriction that it ensures a fair bet if the null is true. Formally, this is imposed by requiring $S_t$ to satisfy $\mathbb{E}_P[S_t(Z_t)</td>
          <td>\mathcal{F}_{t-1}] = 1$ (or more generally, $\mathbb{E}_P[S_t(Z_t)</td>
          <td>\mathcal{F}<em>{t-1}] \leq 1$) for all $P \in \mathcal{P}</em>{\text{null}}$, where $\mathcal{F}<em>{t-1} = \sigma(Z_1,\ldots,Z</em>{t-1})$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Then, the outcome $Z_t$ is revealed, and the bettor’s wealth grows (or possibly shrinks) by a factor of $S_t(Z_t)$. Thus, the bettor’s wealth after $t$ rounds of betting is $K_t = K_0 \prod_{i=1}^t S_i(Z_i)$.</li>
</ol>

<p>The restriction on the conditional expectation of the payoff functions implies that under the null, ${K_t : t \geq 0}$ is a test martingale, which is a nonnegative martingale with an initial value 1. Due to this fact, $K_t$ is unlikely to take large values for any $t \geq 1$.</p>

<p>On the other hand, when $H_1$ is true, the bettor’s choice of payoff functions, ${S_t : t \geq 1}$ should ensure that the wealth process grows exponentially. Such a wealth process naturally leads to the following sequential test: reject the null if $K_t \geq 1/\alpha$, where $\alpha \in (0, 1)$ is the desired confidence level. Ville’s maximal inequality[^1] ensures that this test controls the type-I error at level $\alpha$.</p>

<table>
  <tbody>
    <tr>
      <td>When testing simple hypotheses $H_0: Z_t \sim P$ and $H_1: Z_t \sim Q$ with $P$ and $Q$ known, the payoff fucntion $S_t$ is just the likelihood ratio $dQ/dP$. With this choice of payoff functions, we have $\mathbb{E}_P[S_t</td>
      <td>\mathcal{F}_{t-1}] = 1$, meaning it is a fair bet under the null. Under $H_1$, the wealth process with this payoff grows exponentially, with an optimal (expected) growth rate of $\text{KL}(Q, P)$: the KL-divergence between $Q$ and $P$.</td>
    </tr>
  </tbody>
</table>

<p>When dealing with cases where either one or both of $H_0$ and $H_1$ are composite and nonparametric there is no obvious choice for the payoff functions. So there are a couple of design choices we need to make before we can use the testing by betting framework:</p>

<ol>
  <li>In which function class should $S_t$ lie?</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>How to ensure $\mathbb{E}[S_t</td>
          <td>\mathcal{F}<em>{t-1}] = 1$ uniformly over $\mathcal{P}</em>{\text{null}}$;</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>How to ensure fast growth of $K_t$ under the alternative?</li>
</ol>

<p>Before we continue with the exposition, we first define a sequential test:</p>

<blockquote>
  <p><strong>Definition 1</strong> (sequential-test). A level-$\alpha$ sequential test can be represented by a random stopping time $\tau$ taking values in ${1, 2, \ldots} \cup {\infty}$, and satisfying the condition $\mathbb{P}(\tau &lt; \infty) \leq \alpha$, under the null $H_0$. Thus, $\tau$ denotes the random time at which the null hypothesis is rejected.</p>
</blockquote>

<h2 id="the-function-class">The function class</h2>

<h2 id="how-it-works">How It Works</h2>

<h3 id="the-basic-setup">The Basic Setup</h3>

<ul>
  <li>Start with $1 of betting capital</li>
  <li>For each new observation, you place a bet</li>
  <li>If your betting capital reaches $1/\alpha$ (e.g., $20 for $\alpha=0.05$), you reject the null hypothesis</li>
</ul>

<p>This setup satisfies a crucial property: under the null hypothesis, your betting capital is a martingale - meaning your expected future wealth equals your current wealth. This property ensures proper Type I error control.</p>

<h3 id="the-betting-process">The Betting Process</h3>

<p>For each observation:</p>

<ul>
  <li>Choose a betting amount (constrained to ensure you can’t lose all your money)</li>
  <li>Observe the outcome</li>
  <li>Update your wealth based on the bet’s outcome</li>
</ul>

<p>The martingale approach handles this in the context of your bidding strategies. In the paper, Section 2.1 covers this through the filtration ${\mathcal{F}_{t-1}}$ concept. Here’s what’s happening:</p>

<p>At each time $t$, the betting decision ($\lambda_t$) and prediction strategy ($g_t$) must be $\mathcal{F}_{t-1}$-measurable, meaning they can only use information available up to time $t-1$. This accounts for time dependencies because:</p>

\[\mathbb{E}[g_t(X_t) - g_t(Y_t)|\mathcal{F}_{t-1}] = 0\]

<p>For your bidding scenario specifically:</p>

<ul>
  <li>Each day’s bids and outcomes aren’t independent (today’s bidding may be influenced by yesterday’s performance)</li>
  <li>But the relative performance difference between strategies each day can still be used for betting</li>
</ul>

<p>The key adaptation for our case would be:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_bet</span><span class="p">(</span><span class="n">day_data</span><span class="p">,</span> <span class="n">history</span><span class="p">):</span>
    <span class="c1"># Use history to normalize daily performance
</span>    <span class="n">normalized_roi_diff</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">day_data</span><span class="p">[</span><span class="s">'adaptive_roi'</span><span class="p">]</span> <span class="o">-</span> <span class="n">day_data</span><span class="p">[</span><span class="s">'fixed_roi'</span><span class="p">])</span> <span class="o">/</span>
        <span class="n">get_historical_volatility</span><span class="p">(</span><span class="n">history</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalized_roi_diff</span><span class="p">))</span>
</code></pre></div></div>

<p>Crucially, in the paper’s Remark 7 (page 13):</p>

<p>“The results stated above in Theorem 1 are valid under a much weaker assumption that the stream ${(X_t,Y_t) : t \geq 1}$ consists of independent pairs of observations satisfying $(X_t,Y_t) \stackrel{d}{=} (Y_t,X_t)$ under the null.”</p>

<p>This means we only need:</p>

<ul>
  <li>Each day’s comparison to be a fair test under the null</li>
  <li>The betting strategy to only use past information</li>
</ul>

<p>We don’t need full independence between days, which makes this approach particularly suitable for our adaptive bidding scenario.</p>

<p>The full implementation is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">class</span> <span class="nc">ROISequentialTester</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_wealth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">min_effect</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.10</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">initial_wealth</span> <span class="o">=</span> <span class="n">initial_wealth</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">min_effect</span> <span class="o">=</span> <span class="n">min_effect</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">=</span> <span class="n">initial_wealth</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">daily_wealth_history</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_wealth</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">calculate_bet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">day_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">"""
        Calculate bet size based on ROI comparison
        Returns a fraction of current wealth to bet
        """</span>
        <span class="n">adaptive_roi</span> <span class="o">=</span> <span class="p">(</span><span class="n">day_data</span><span class="p">[</span><span class="s">'adaptive_revenue'</span><span class="p">]</span> <span class="o">-</span> <span class="n">day_data</span><span class="p">[</span><span class="s">'adaptive_spend'</span><span class="p">])</span> <span class="o">/</span> <span class="n">day_data</span><span class="p">[</span><span class="s">'adaptive_spend'</span><span class="p">]</span>
        <span class="n">fixed_roi</span> <span class="o">=</span> <span class="p">(</span><span class="n">day_data</span><span class="p">[</span><span class="s">'fixed_revenue'</span><span class="p">]</span> <span class="o">-</span> <span class="n">day_data</span><span class="p">[</span><span class="s">'fixed_spend'</span><span class="p">])</span> <span class="o">/</span> <span class="n">day_data</span><span class="p">[</span><span class="s">'fixed_spend'</span><span class="p">]</span>
        
        <span class="c1"># Calculate relative ROI improvement
</span>        <span class="n">relative_improvement</span> <span class="o">=</span> <span class="p">(</span><span class="n">adaptive_roi</span> <span class="o">-</span> <span class="n">fixed_roi</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fixed_roi</span><span class="p">)</span> <span class="k">if</span> <span class="n">fixed_roi</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        
        <span class="c1"># Scale bet to [-0.5, 0.5] range and center around minimum effect
</span>        <span class="n">bet</span> <span class="o">=</span> <span class="p">(</span><span class="n">relative_improvement</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">min_effect</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bet</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">update_wealth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">day_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">"""Update wealth based on day's ROI comparison"""</span>
        <span class="n">bet_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">calculate_bet</span><span class="p">(</span><span class="n">day_data</span><span class="p">)</span>
        <span class="n">bet_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">*</span> <span class="n">bet_fraction</span>
        
        <span class="c1"># Update wealth with proportional returns
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">+=</span> <span class="n">bet_amount</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">daily_wealth_history</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">wealth</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span>
    
    <span class="k">def</span> <span class="nf">check_stopping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="s">"""Check if we should stop the test"""</span>
        <span class="c1"># Adjusted threshold based on initial wealth
</span>        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">initial_wealth</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="s">"Reject null hypothesis - Adaptive strategy shows significant ROI improvement"</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">wealth</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">initial_wealth</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">alpha</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="s">"Accept null hypothesis - Insufficient evidence for ROI improvement"</span>
        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="s">"Continue testing"</span>

<span class="k">def</span> <span class="nf">simulate_roi_data</span><span class="p">(</span><span class="n">days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="s">"""Simulate daily ROI data for both strategies"""</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">days</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Fixed strategy
</span>        <span class="n">fixed_spend</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rng</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>  <span class="c1"># Base spend with 10% variance
</span>        <span class="n">fixed_revenue</span> <span class="o">=</span> <span class="n">fixed_spend</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.2</span> <span class="o">+</span> <span class="n">rng</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>  <span class="c1"># 20% average ROI
</span>        
        <span class="c1"># Adaptive strategy (assumed 30% better on average with more variance)
</span>        <span class="n">adaptive_spend</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rng</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">))</span>
        <span class="n">adaptive_revenue</span> <span class="o">=</span> <span class="n">adaptive_spend</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">+</span> <span class="n">rng</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">))</span>
        
        <span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s">'day'</span><span class="p">:</span> <span class="n">day</span><span class="p">,</span>
            <span class="s">'fixed_spend'</span><span class="p">:</span> <span class="n">fixed_spend</span><span class="p">,</span>
            <span class="s">'fixed_revenue'</span><span class="p">:</span> <span class="n">fixed_revenue</span><span class="p">,</span>
            <span class="s">'adaptive_spend'</span><span class="p">:</span> <span class="n">adaptive_spend</span><span class="p">,</span>
            <span class="s">'adaptive_revenue'</span><span class="p">:</span> <span class="n">adaptive_revenue</span>
        <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">run_roi_experiment</span><span class="p">(</span>
    <span class="n">initial_wealth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">num_days</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">num_simulations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">min_effect</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.10</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="s">"""Run multiple simulations of the ROI-based sequential test"""</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_simulations</span><span class="p">):</span>
        <span class="c1"># Generate data
</span>        <span class="n">data</span> <span class="o">=</span> <span class="n">simulate_roi_data</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">num_days</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">sim</span><span class="p">)</span>
        
        <span class="c1"># Run test
</span>        <span class="n">tester</span> <span class="o">=</span> <span class="n">ROISequentialTester</span><span class="p">(</span>
            <span class="n">initial_wealth</span><span class="o">=</span><span class="n">initial_wealth</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">min_effect</span><span class="o">=</span><span class="n">min_effect</span>
        <span class="p">)</span>
        
        <span class="n">stop_day</span> <span class="o">=</span> <span class="n">num_days</span>
        <span class="n">final_decision</span> <span class="o">=</span> <span class="s">"Inconclusive"</span>
        
        <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_days</span><span class="p">):</span>
            <span class="n">day_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">day</span><span class="p">]</span>
            <span class="n">wealth</span> <span class="o">=</span> <span class="n">tester</span><span class="p">.</span><span class="n">update_wealth</span><span class="p">(</span><span class="n">day_data</span><span class="p">)</span>
            <span class="n">should_stop</span><span class="p">,</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">tester</span><span class="p">.</span><span class="n">check_stopping</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">should_stop</span><span class="p">:</span>
                <span class="n">stop_day</span> <span class="o">=</span> <span class="n">day</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">final_decision</span> <span class="o">=</span> <span class="n">decision</span>
                <span class="k">break</span>
        
        <span class="n">results</span><span class="p">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s">'simulation'</span><span class="p">:</span> <span class="n">sim</span><span class="p">,</span>
            <span class="s">'stop_day'</span><span class="p">:</span> <span class="n">stop_day</span><span class="p">,</span>
            <span class="s">'final_wealth'</span><span class="p">:</span> <span class="n">tester</span><span class="p">.</span><span class="n">wealth</span><span class="p">,</span>
            <span class="s">'initial_wealth'</span><span class="p">:</span> <span class="n">initial_wealth</span><span class="p">,</span>
            <span class="s">'decision'</span><span class="p">:</span> <span class="n">final_decision</span><span class="p">,</span>
            <span class="s">'wealth_history'</span><span class="p">:</span> <span class="n">tester</span><span class="p">.</span><span class="n">daily_wealth_history</span>
        <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

<span class="c1"># Run experiments with different initial wealth levels
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">initial_wealths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
    <span class="n">all_results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">initial_wealth</span> <span class="ow">in</span> <span class="n">initial_wealths</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">run_roi_experiment</span><span class="p">(</span>
            <span class="n">initial_wealth</span><span class="o">=</span><span class="n">initial_wealth</span><span class="p">,</span>
            <span class="n">num_days</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
            <span class="n">num_simulations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
            <span class="n">min_effect</span><span class="o">=</span><span class="mf">0.10</span>
        <span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s">'initial_wealth'</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_wealth</span>
        <span class="n">all_results</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    
    <span class="n">combined_results</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span><span class="n">all_results</span><span class="p">)</span>
    
    <span class="c1"># Plot results
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">initial_wealth</span> <span class="ow">in</span> <span class="n">initial_wealths</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">combined_results</span><span class="p">[</span><span class="n">combined_results</span><span class="p">[</span><span class="s">'initial_wealth'</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial_wealth</span><span class="p">]</span>
        
        <span class="c1"># Plot first 5 simulations for each initial wealth
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">))):</span>
            <span class="n">wealth_history</span> <span class="o">=</span> <span class="n">subset</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'wealth_history'</span><span class="p">]</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wealth_history</span><span class="p">,</span> 
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s">'Initial Wealth $</span><span class="si">{</span><span class="n">initial_wealth</span><span class="si">:</span><span class="p">,</span><span class="si">}</span><span class="s">'</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
            
        <span class="c1"># Plot threshold line
</span>        <span class="n">plt</span><span class="p">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">initial_wealth</span><span class="o">/</span><span class="mf">0.05</span><span class="p">,</span> 
                   <span class="n">linestyle</span><span class="o">=</span><span class="s">'--'</span><span class="p">,</span> 
                   <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                   <span class="n">color</span><span class="o">=</span><span class="s">'gray'</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Day'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Wealth ($)'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ROI-Based Sequential Testing with Different Initial Wealth Levels'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">yscale</span><span class="p">(</span><span class="s">'log'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="c1"># Print summary statistics
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Experiment Summary by Initial Wealth:"</span><span class="p">)</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="n">combined_results</span><span class="p">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">'initial_wealth'</span><span class="p">).</span><span class="n">agg</span><span class="p">({</span>
        <span class="s">'stop_day'</span><span class="p">:</span> <span class="p">[</span><span class="s">'mean'</span><span class="p">,</span> <span class="s">'std'</span><span class="p">],</span>
        <span class="s">'decision'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">value_counts</span><span class="p">().</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}).</span><span class="nb">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>
</code></pre></div></div>

<p>[^1] <a href="https://en.wikipedia.org/wiki/Ville%27s_inequality">Ville’s inequality</a> bounds the maximum of a martingale by its mean.</p>

        </div>
        
    </div>
</body>
</html>